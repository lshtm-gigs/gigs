---
title: "Benchmarking gigs against other software packages"
description: >
  A comparison of gigs' performance against other growth analysis packages.
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  dpi = 120, message = FALSE, warning = FALSE, comment = "#>",
  dev.args = list(png = list(type = "cairo"))
)

# Set ggplot theming for consistent plots
ggplot2::theme_set(ggplot2::theme_bw())

intergrowth21st <- if (knitr::is_html_output()) {
  knitr::asis_output(x = "INTERGROWTH-21<sup>st</sup>")
} else {
  knitr::asis_output(x = "INTERGROWTH-21\textsupercript{st}")
}
```

```{r srr-tags, eval = FALSE, echo = FALSE}
#' @srrstats {1.5, 1.6} This article contains code for both performance and
#'   accuracy claims when comparing this package with other software packages.
```

```{r load_timings_rda, echo = FALSE}
load(file = file.path("benchmarking.rda"))
```

# Rationale
This short article describes the performance of **gigs** relative to a
non-exhaustive group of R and non-R packages which implement international
growth standards which are also found in **gigs**.

```{r pkgnames, echo = FALSE}
anthro <- knitr::asis_output(x = "[anthro](https://cran.r-project.org/web/packages/anthro/index.html)")
AGD <- knitr::asis_output(x = "[AGD](https://cran.r-project.org/web/packages/AGD/index.html)")
childsds <- knitr::asis_output(x = "[childsds](https://cran.r-project.org/web/packages/childsds/index.html)")
gigs_r <- knitr::asis_output(x = "[gigs](https://www.github.com/ropensci/gigs/)")
growthstans <- knitr::asis_output(x = "[ki-tools/growthstandards](https://www.github.com/ki-tools/growthstandards/)")
sitar <- knitr::asis_output(x = "[sitar](https://cran.r-project.org/web/packages/sitar/index.html)")
zscorer <- knitr::asis_output(x = "[zscorer](https://cran.r-project.org/web/packages/zscorer/index.html)")
gigs_stata <- knitr::asis_output(x = "[gigs](https://www.github.com/lshtm-gigs/gigs-stata/) (Stata)")
zanthro <- knitr::asis_output(x = "[zanthro](https://journals.sagepub.com/doi/epdf/10.1177/1536867X1301300211) (Stata)")
intergrowth <- knitr::asis_output(x = "[nutriverse/intergrowth](https://github.com/nutriverse/intergrowth/)")
gigs_sas <- knitr::asis_output(x = "[gigs](https://github.com/SASPAC/gigs/) (SAS)")
```

| Package name    | Language | On CRAN? |
|-----------------|:---------|:---------|
| `r gigs_r`      | R        | Yes      |
| `r anthro`      | R        | Yes      |
| `r AGD`         | R        | Yes      |
| `r childsds`    | R        | Yes      |
| `r sitar`       | R        | Yes      |
| `r zscorer`     | R        | Yes      |
| `r growthstans` | R        | No       |
| `r intergrowth` | R        | No       |
| `r gigs_stata`  | Stata    | No       |
| `r zanthro`     | Stata    | No       |
| `r gigs_sas`    | SAS      | No       |

Thus far, there is no comprehensive benchmark comparing these different
packages. This short article will compare the speed of each package from 1 to
100000 inputs, checking how fast each package can convert weight values to
z-scores in different growth standards.

We performed these benchmarks on R version
`r session_info[[1]][["major"]]`.`r session_info[[1]][["minor"]]`, using a
Windows 10 system with a Ryzen 7 3700X processor and 16GB of DDR4 RAM. The Stata
benchmarks were run in Stata 18.0 (revision 16 Oct 2024) on the same system,
using the [benchmark](https://github.com/mcaceresb/stata-benchmark) package for
Stata. The SAS benchmarks were also performed on this system, using SAS 9.4
(9.04.01M6P111518), in a custom benchmarking process detailed in a code block
at the bottom of this article.

```{r yes_no_half, echo = FALSE}
yes <- if (knitr::is_html_output()) {
   knitr::asis_output(x = "✅")
} else {
  knitr::asis_output(x = "✓")
}
no <- if (knitr::is_html_output()) {
  knitr::asis_output(x = "❌")
} else {
  knitr::asis_output(x = "✘")
}
half <- if (knitr::is_html_output()) {
  knitr::asis_output(x = "⚠️")
} else {
  knitr::asis_output(x = "⚠")
}
```

Other R packages can be used to analyse growth data with international
standards, but have limitations which are not present in **gigs**. There are
also software packages external to R which implement these standards. The table
below describes these packages, and to what extent they have implemented
functions that let users convert anthropometric measurements to
z-scores/centiles in each set of standards implemented in **gigs** - the WHO
Child Growth standards, `r intergrowth21st` Newborn Size standards (including
Very Preterm), and the `r intergrowth21st` Postnatal Growth standards for
preterm infants. No other packages (except **gigs** for Stata) includes the
extended versions of the `r intergrowth21st` Newborn Size standards (incl. Very
Preterm).

A tick (`r yes`) indicates that all possible standards are
included in a package, a red cross (`r no`) indicates that these standards are
completely missing, and a warning sign (`r half`) indicates that some of these
standards are implemented but not others.

```{r arrows, echo = FALSE}
ig21st <- if (knitr::is_html_output()) {
  knitr::asis_output(x = "IG-21<sup>st</sup>")
} else {
  knitr::asis_output(x = "IG-21\textsupercript{st}")
}

larr <- knitr::asis_output(x = "&larr;")
rarr <- knitr::asis_output(x = "&rarr;")
harr <- knitr::asis_output(x = "&harr;")
```

| Software        | Platform | WHO (0-5 years) | `r ig21st` NBS | `r ig21st` PNG | `r ig21st` Fetal | Functionality                     |
|-----------------|----------|-----------------|----------------|----------------|------------------|-----------------------------------|
| `r gigs_r`      | R        | `r yes`         | `r yes`        | `r yes`        | `r yes`          | Values `r harr` z-scores/centiles |
| `r anthro`      | R        | `r yes`         | `r no`         | `r no`         | `r no`           | Values `r rarr` z-scores          |
| `r AGD`         | R        | `r yes`         | `r no`         | `r no`         | `r no`           | Values `r harr` z-scores          |
| `r childsds`    | R        | `r yes`         | `r no`         | `r no`         | `r no`           | Values `r rarr` z-scores/centiles |
| `r growthstans` | R        | `r yes`         | `r yes`        | `r half`       | `r half`         | Values `r harr` z-scores/centiles |
| `r intergrowth` | R        | `r no`          | `r no`         | `r no`         | `r half`         | Values `r rarr` z-scores/centiles |
| `r sitar`       | R        | `r yes`         | `r no`         | `r no`         | `r no`           | Values `r harr` z-scores/centiles |
| `r zscorer`     | R        | `r yes`         | `r no`         | `r no`         | `r no`           | Values `r rarr` z-scores/centiles |
| `r gigs_stata`  | Stata    | `r yes`         | `r yes`        | `r yes`        | `r yes`          | Values `r harr` z-scores/centiles |
| `r zanthro`     | Stata    | `r yes`         | `r no`         | `r no`         | `r no`           | Values `r rarr` z-scores/centiles |
| `r gigs_sas`    | SAS      | `r yes`         | `r yes`        | `r yes`        | `r yes`          | Values `r harr` z-scores/centiles |

# Shared benchmark code

```{r load_gigs}
library(gigs)
```

In this vignette, we perform benchmark performance in each a growth standard
from each set of growth standards implemented in **gigs**, excluding the
extended `r intergrowth21st` Newborn Size standards. These are the:

* WHO Child Growth Standards (0-5 years)
* `r intergrowth21st` Newborn Size standards
* `r intergrowth21st` Postnatal Growth standards
* `r intergrowth21st` Fetal standards

The benchmarks utilise pre-generated datasets for growth standard. The z-scores,
`x` variable and sexes for each row are generated (pseudo)randomly. Because the
**gigs** test suite validates its functions against published growth curve data
from the WHO and the `r intergrowth21st` Project, we use **gigs** to generate
expected measurements for each observation. This dataset can then be used to
compare speeds for each package. These datasets are generated with the following
function:
```{r benchmark_dataset, echo = TRUE}
benchmark_dataset <- function(n, family, acronym) {
  data <- get(family, envir = asNamespace("gigs"))
  if (family == "ig_fet") {
    xvars <- data[[acronym]][[1]][[1]]
  } else {
    xvars <- data[[acronym]][[1]][[1]][[1]]
  }

  withr::with_seed(seed = 154237890, code = {
      # Random z-scores around 0
      z <- rnorm(n = n)
    })
  withr::with_seed(seed = 154237890, code = {
      # X variables are non-discrete but within bounds of the desired acronym
      x <-  sample(xvars, size = n, replace = TRUE)
      x_jitter <- c(runif(n = 5, min = -1, max = 1), 0)
      x <- x + sample(x_jitter, size = n, replace = TRUE)
      x <- pmax(pmin(x, max(xvars)), min(xvars))
      # Sexes randomly sampled from male and female
      sex <- sample(c("M", "F"), size = n, replace = TRUE)
    }
  )
  gigs_fn <- get("zscore2value", envir = asNamespace("gigs"))
  out <- if (family != "ig_fet") {
    list(z = z, x = x, sex = sex, family = family, acronym = acronym)
  } else {
    list(z = z, x = x, family = family, acronym = acronym)
  }
  out$y <- do.call(what = gigs_fn, args = out)
  if (family == "ig_fet") {
    out$sex <- NA
  }
  as.data.frame(out, stringsAsFactors = FALSE)
}
```

```{r hidden_helpers, echo = FALSE}
max_median <- function(bp, name) {
  round(max(bp[bp$desc == name, "median"]))
}

pkg_str <- function(pkgname) paste("R:", pkgname, packageVersion(pkg = pkgname))

ver_zanthro_stata <- "1.0.2"
ver_gigs_sas <- "0.1.8"
ver_gigs_stata <- "1.1.1"
plot_bp <- function(bp) {
  key_pkg_colour <- c("gs" = "#925E9FFF",
                      "gigs" = "#00468BFF",
                      "anthro" = "#AD002AFF",
                      "AGD" = "#FFA3FF",
                      "intergrowth" = "#FDAF91FF",
                      "childsds" = "#663300FF",
                      "sitar" = "#005500FF",
                      "zscorer" = "#009900",
                      "gigs_stata" = "skyblue",
                      "zanthro_stata" = "darkolivegreen4",
                      "gigs_sas" = "#8585e0")
  key_pkg_label <- c("gs" = pkg_str("growthstandards"),
                     "gigs" = pkg_str("gigs"),
                     "anthro" = pkg_str("anthro"),
                     "AGD" = pkg_str("AGD"),
                     "intergrowth" = pkg_str("intergrowth"),
                     "childsds" = pkg_str("childsds"),
                     "sitar" = pkg_str("sitar"),
                     "zscorer" = pkg_str("zscorer"),
                     "gigs_stata" = paste("Stata: gigs", ver_gigs_stata),
                     "zanthro_stata" = paste("Stata: zanthro",
                                             ver_zanthro_stata),
                     "gigs_sas" = paste("SAS: gigs", ver_gigs_sas))
  key_pkg_breaks <- dplyr::summarise(bp, max_time = max(median), .by = desc) |>
    dplyr::arrange(max_time) |>
    dplyr::pull(desc) |>
    rev()
  key_pkg_label <- key_pkg_label[names(key_pkg_label) %in% key_pkg_breaks]
  bp |>
    ggplot2::ggplot(ggplot2::aes(x = input_len, y = median, colour = desc)) +
    ggplot2::geom_line() +
    ggplot2::geom_point(colour = "black") +
    ggplot2::labs(x = "Input lengths", y = "Median time taken (ms)",
                  colour = "Package") +
    ggplot2::scale_colour_manual(values = key_pkg_colour,
                                 labels = key_pkg_label,
                                 breaks = key_pkg_breaks) +
    ggplot2::theme_bw()
}
```

We're using the `{bench}` package throughout this vignette, specifically the
`bench::press()` function, which lets us compare function scaling by iterating
through increasing numbers of observations.

# WHO Growth Standards
The World Health Organisation (WHO) Child Growth Standards describe postnatal
growth in multiple anthropometric measures from birth (0 days) to up to 1856
days for specific standards (e.g. weight-for-age), and are also implemented in a
variety of other packages.

## Set up benchmark dataset

```{r ds_who_gs}
# Generate 100,000-row dataset
ac_who_gs <- "wfa"
ds_who_gs <- benchmark_dataset(n = 100000,
                               family = "who_gs",
                               acronym = ac_who_gs)
```

The first 10 rows of this dataset look like this:
```{r show_bench_dataset_who_gs, echo = FALSE}
ds_who_gs[1:10, ]
```


## Timing
### R
```{r bp_who_gs, echo = TRUE, eval = FALSE}
temp_bp_who_gs_most <- bench::press(
  input_len = c(1, 1000, 10000, seq(25000, 100000, 25000)),
  {
    selector <- seq_len(input_len)
    weight_kg <- ds_who_gs$y[selector]
    age_days <- ds_who_gs$x[selector]
    acronym <- ds_who_gs$acronym[selector]
    sex <- ds_who_gs$sex[selector]
    sex_gs <- ifelse(sex == "M", "Male", "Female")
    age_years <- age_days / 365.25
    bm_who_gs <- bench::mark(
      check = FALSE, filter_gc = TRUE, time_unit = "ms", min_iterations = 30,
      gigs = gigs::value2zscore(weight_kg, age_days, sex,
                                family = "who_gs", acronym = ac_who_gs),
      anthro = anthro::anthro_zscores(weight = weight_kg,
                                      age = age_days,
                                      sex = sex)$zwei,
      AGD = AGD::y2z(y = weight_kg,
                     x = age_days,
                     sex = sex,
                     ref = AGD::who.wgt,
                     tail.adjust = TRUE),
      childsds = childsds::sds(value = weight_kg,
                              age = age_years,
                              sex = sex,
                              male = "M",
                              female = "F",
                              item = "weight",
                              ref = childsds::who.ref),
      gs = growthstandards::who_value2zscore(y = weight_kg, x = age_days,
                                             y_var = "wtkg", x_var = "agedays",
                                             sex = sex_gs),
      sitar = sitar::LMS2z(y = weight_kg, x = age_years, sex = sex,
                          measure = "wt", ref = sitar::who06)
    )
  })

temp_bp_who_gs_zscorer <- bench::press(
  input_len = c(1, 1000, 5000, 10000, 15000),
  {
    selector <- seq_len(input_len)
    weight_kg <- ds_who_gs$y[selector]
    age_days <- ds_who_gs$x[selector]
    sex <- ds_who_gs$sex[selector]
    df_zscorer <- data.frame(
      weight = weight_kg, age = age_days,
      sex = ifelse(sex == "M", 1, 2)
    )
    bm_who_gs <- bench::mark(
      check = FALSE, filter_gc = TRUE, time_unit = "ms", max_iterations = 5,
      zscorer = zscorer::addWGSR(
        df_zscorer, sex = "sex", firstPart = "weight", secondPart = "age",
        index = "wfa"
      )
    )
  })

bp_who_gs_r <- dplyr::bind_rows(temp_bp_who_gs_most, temp_bp_who_gs_zscorer) |>
  dplyr::mutate(desc = attr(expression, which = "description")) |>
  dplyr::select(input_len, median, desc)
```

### Stata
```{r stata_ds_who_gs, eval = FALSE}
# Save .dta file equivalent of benchmarking table. This can be used to benchmark
# Stata packages.
haven::write_dta(
  data = ds_who_gs,
  path = file.path("exclude", "statabench", "bench_ds_who_gs.dta")
)
```

In Stata, the commands are run inside a do-file which utilises the
[benchmark](https://www.github.com/mcaceresb/stata-benchmark) package for Stata.
This code essentially does the same as `bench::press()`, but for the packages
we're testing in Stata.

```{stata stata_bench_code_who_gs, eval = FALSE}
// This is Stata code
foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_who_gs.dta", clear
	qui drop if _n > `i'
	di "For who_gs gigs_stata - Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen double z_gigs = who_gs(y, "wfa", "v2z"), ///
			xvar(x) sex(sex) sexcode(m=M, f=F)
}

foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_who_gs.dta", clear
	qui drop if _n > `i'
	di "For who_gs zanthro_stata - Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen z_anthro = zanthro(y, wa, WHO), xvar(x) gender(sex) ///
			gencode(male=M, female=F) ageunit(day)
}
```

```{r bp_who_gs_stata, echo = FALSE, eval = FALSE}
bp_who_gs_stata <- read.csv("exclude/statabench/stata_bench.csv")
bp_who_gs_stata <- bp_who_gs_stata[bp_who_gs_stata$acronym == "who_gs", ]
bp_who_gs_stata <- bp_who_gs_stata[, -4]
```

### SAS
```{r sas_ds_who_gs, eval = FALSE}
# Save .txt file equivalent of benchmarking table. This can be used to benchmark
# SAS package.
write.table(ds_who_gs,
            file = file.path("exclude", "sasbench", "bench_ds_who_gs.txt"),
            sep = ",",
            row.names = FALSE,
            col.names = FALSE,
            quote = FALSE)
```

In SAS, the commands are run inside a script described at the [bottom of this
article](#sas-code). This code essentially does the same as `bench::press()`,
but for the SAS implementation of **gigs**.

```{r bp_who_gs_sas, echo = FALSE, eval = FALSE}
sas_who_gs <- read.csv("exclude/sasbench/sas_bench.csv")
sas_who_gs <- sas_who_gs[sas_who_gs$family == "who_gs", ]
bp_who_gs_sas <- data.frame(input_len = sas_who_gs$k,
                            median = sas_who_gs$median,
                            desc = "gigs_sas")
rm(sas_who_gs)
```

## Package comparisons: timing
```{r make_bp_who_gs, eval = FALSE, echo = FALSE}
bp_who_gs <- dplyr::bind_rows(bp_who_gs_r, bp_who_gs_stata, bp_who_gs_sas)
```

```{r plot_timings_who_gs, echo = FALSE, fig.alt = "A line graph of median time taken against no. of inputs for different software packages. The results can be read about below."}
plot_bp(bp_who_gs)
```

On the whole, **zscorer** is by far the slowest R package, taking around
`r max_median(bp_who_gs, "zscorer") / 1000` seconds to process 15,000 inputs. We
couldn't get it to process 100,000 inputs in good time. Looking at the source
code, this is because `zscorer::addWGSR()` hasn't been vectorised.

Next slowest is **anthro**, which takes
`r max_median(bp_who_gs, "anthro") / 1000` seconds to process 100,000 inputs.
This slowdown arises from **anthro** computing results in every WHO Child Growth
standard each time `anthro::anthro_zscores()` is called, but also due to a
slower implementation of the WHO LMS procedure than the other R packages.

Next slowest is the Stata package **zanthro**, which takes around
`r max_median(bp_who_gs, "zanthro_stata") / 1000` seconds to compute
results in a single WHO standard. About 4 times faster than **zanthro** is
**gigs** for Stata, which scales more efficiently than **zanthro** and takes
around `r max_median(bp_who_gs, "gigs_stata") / 1000` seconds to convert
100,000 measurements to z-scores.

Focussing now on the faster implementations reveals some interesting patterns:

```{r plot_timings_who_gs_faster, echo = FALSE, fig.alt = "A line graph of median time taken against no. of inputs for a faster subset of the software packages analysed. The results can be read about below."}
bp_who_gs |>
  dplyr::filter(desc %in% c("gigs", "childsds", "gs", "sitar", "AGD",
                            "gigs_sas")) |>
  plot_bp()
```

The **sitar** package is far and away the fastest here, taking
~`r max_median(bp_who_gs, "sitar")` ms to process 100,000 inputs. This is
because it uses the monthly LMS coefficients to calculate its z-scores. Whilst
this is quicker, it does induce some imprecision when compared to the other
packages.

In R, the next fastest was the **growthstandards** package at
~`r max_median(bp_who_gs, "gs")` ms for 100,000 inputs, followed by **gigs**
(~`r max_median(bp_who_gs, "gigs")` ms), **AGD**
(~`r max_median(bp_who_gs, "AGD")` ms, and lastly **childsds**
(~`r max_median(bp_who_gs, "childsds")` ms).

If you're a SAS user, you'll find **gigs** for SAS slower than its R
equivalent, but still much faster than Stata at
~`r max_median(bp_who_gs, "gigs_sas")` milliseconds.

Interestingly, **AGD** starts out much slower than the other 'fast' R packages,
but may scale more efficiently as you reach larger sets of inputs. Additionally,
**gigs** is faster than **growthstandards** up to ~34,000 inputs but ends up
slower at 100,000 inputs. This may be due to the input checks performed in
**gigs**, which scale worse than the conversion code itself.

## Package comparisons: numerical consistency
In our testing of the WHO standards, we found that the tested packages mostly
agreed with each other when provided the same inputs, except for **childsds**
and **sitar**.

For **childsds**, this is because the WHO Child Growth standards constrain
z-scores in the outer tails (i.e. past 3 z-scores), as their data was more
sparse for these extreme values. More information on this constraining procedure
can be found in the reports referenced in the `gigs::who_gs` documentation. It
appears that **childsds** does not perform this constraining procedure, so
conversions where `abs(z_score) > 3` are computed incorrectly:

```{r discrepancies_who_gs}
discrepancies <- data.frame(z = c(-3.03, -2.97, 2.97, 3.03),
                            age_days = 0,
                            sex = "M") |>
  dplyr::mutate(
    weight_kg = gigs::zscore2value(z, age_days, sex, "who_gs", "wfa"),
    # GIGS z-score
    z_gigs = gigs::value2zscore(weight_kg, age_days, sex, "who_gs", "wfa"),
    # growthstandards z-score
    z_growthstandards = growthstandards::who_wtkg2zscore(
      age_days, weight_kg, "Male"
    ),
    # childsds z-score
    z_childsds = childsds::sds(
      value = weight_kg, age = age_days / 365.25,
      sex = sex, male = "M", female = "F",
      item = "weight", ref = childsds::who.ref
    )
  )
```

When we look at these z-scores, you can see that both **growthstandards** and
**gigs** correctly apply the constraining procedure; **childsds** does not.
**AGD** constrains z-scores if the `tail.adjust` option in `AGD::y2z()` is
specified, and from looking at the **anthro** source code, they also apply the
constraining procedure.

```{r discrepancies_who_gs_kable, echo = FALSE}
knitr::kable(discrepancies, align = "ccccc")
```

Discrepancies between **sitar** and **gigs** arise from **sitar** relying on monthly
LMS values for the WHO Growth Standards, instead of the daily tables. This means
for the same day, **sitar** and **gigs** will use slightly different lambda/mu/sigma
values, and so compute different z-scores for the same measurements.

# INTERGROWTH-21<sup>st</sup> Newborn Size standards
The `r intergrowth21st` Newborn Size standards are implemented in gigs for R and
Stata, and in the **growthstandards** package for R. Let's make a new dataset,
`ds_ig_nbs`, which we will use to benchmark these functions:

```{r ds_ig_nbs}
ac_ig_nbs <- "wfga"
ds_ig_nbs <- benchmark_dataset(n = 100000,
                               family = "ig_nbs",
                               acronym = ac_ig_nbs)
```


The first 10 rows of this dataset look like this:
```{r show_bench_dataset_ig_nbs}
ds_ig_nbs[1:10, ]
```

## Timing
### R
```{r bp_ig_nbs, echo = TRUE, eval = FALSE}
bp_ig_nbs_r <- bench::press(
  input_len = c(1, 1000, 10000, seq(25000, 100000, 25000)),
  {
    p <- pnorm(ds_ig_nbs$z[1:input_len])
    weight_kg <- ds_ig_nbs$y[1:input_len]
    gest_days <- ds_ig_nbs$x[1:input_len]
    acronym <- ds_ig_nbs$acronym[1:input_len]
    sex <- ds_ig_nbs$sex[1:input_len]
    sex_gs <- ifelse(sex == "M", "Male", "Female")
    bench::mark(
      check = FALSE, filter_gc = TRUE, time_unit = "ms", min_iterations = 50,
      gigs = gigs::value2centile(y =weight_kg, x = gest_days, sex = sex,
                                 family = "ig_nbs", acronym = ac_ig_nbs),
      gs = growthstandards::igb_value2centile(val = weight_kg,
                                              gagebrth = gest_days,
                                              sex = sex_gs, var = "wtkg")
    )
  }) |>
  dplyr::mutate(desc = attr(expression, which = "description")) |>
  dplyr::select(input_len, median, desc)
```

### Stata
```{r, eval = FALSE}
# Save .dta file equivalent of benchmarking table. This can be used to benchmark
# Stata packages.
haven::write_dta(
  data = ds_ig_nbs,
  path = file.path("exclude", "statabench", "bench_ds_ig_nbs.dta")
)
```

We can then benchmark the speed of the Stata command:
```{stata stata_bench_code_ig_nbs, eval = FALSE}
// This is Stata code
foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_ig_nbs.dta", clear
	qui drop if _n > `i'
	di "For ig_nbs gigs_stata - Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen double z_gigs = ig_nbs(y, "wfga", "v2z"), ///
			gest_days(gest_days) sex(sex) sexcode(m=M, f=F)
}
```

```{r bp_ig_nbs_stata, echo = FALSE, eval = FALSE}
bp_ig_nbs_stata <- read.csv("exclude/statabench/stata_bench.csv")
bp_ig_nbs_stata <- bp_ig_nbs_stata[bp_ig_nbs_stata$acronym == "ig_nbs", ]
bp_ig_nbs_stata <- bp_ig_nbs_stata[, -4]
```

### SAS
```{r sas_ds_ig_nbs, eval = FALSE}
# Save .txt file equivalent of benchmarking table. This can be used to benchmark
# SAS package.
write.table(ds_ig_nbs,
            file = file.path("exclude", "sasbench", "bench_ds_ig_nbs.txt"),
            sep = ",",
            row.names = FALSE,
            col.names = FALSE,
            quote = FALSE)
```

In SAS, the commands are run inside a script described at the [bottom of this
article](#sas-code). This code essentially does the same as `bench::press()`,
but for the SAS implementation of **gigs**.

```{r bp_ig_nbs_sas, echo = FALSE, eval = FALSE}
sas_ig_nbs <- read.csv(file = "exclude/sasbench/sas_bench.csv")
sas_ig_nbs <- sas_ig_nbs[sas_ig_nbs$family == "ig_nbs", ]
bp_ig_nbs_sas <-  data.frame(input_len = sas_ig_nbs$k,
                             median = sas_ig_nbs$median,
                             desc = "gigs_sas")
rm(sas_ig_nbs)
```

## Package comparisons: timing
```{r make_bp_ig_nbs, eval = FALSE, echo = FALSE}
bp_ig_nbs <- dplyr::bind_rows(bp_ig_nbs_r, bp_ig_nbs_stata, bp_ig_nbs_sas)
```

```{r plot_timings_ig_nbs, echo = FALSE, fig.alt = "A line graph of median time taken against no. of inputs for the analysed software packages in the INTERGROWTH-21st Newborn Size standard for weight-for-gestational age. The results can be read about below."}
plot_bp(bp_ig_nbs)
```

For this set of growth standards, the Stata implementation for GIGS is the
slowest at ~`r max_median(bp_ig_nbs, "gigs_stata")` ms. Next is
**gigs** for SAS, which is much faster at ~`r max_median(bp_ig_nbs, "gigs_sas")`
ms. The **growthstandards** and **gigs** packages are the fastest at
~`r max_median(bp_ig_nbs, "gs")` ms and ~`r max_median(bp_ig_nbs, "gigs")` ms,
respectively.

## Package comparisons: numerical consistency
In our testing of the `r intergrowth21st` Newborn Size standards, we found that
the implementation in **growthstandards** does not perform coefficient
interpolation for the `r intergrowth21st` Newborn Size standards which
utilise mu/sigma/nu/tau coefficients. Instead, **growthstandards** uses
`round()` to round non-integer gestational ages to the nearest value, then gets
mu/sigma/nu/tau coefficients for this rounded GA. This leads a smaller-scale
version of the z-scoring errors found by
[Kiger *et al.* (2016)](https://dx.doi.org/10.1007/s10916-015-0389-x) when not
interpolating LMS coefficients in the WHO standards.

```{r discrepancies_ig_nbs, eval = TRUE}
weight_kg <- 3
gestage <- seq(274, 278, 0.5)
gigs <- gigs::value2centile(y = weight_kg, x = gestage, sex = "M",
                            family = "ig_nbs", acronym = "wfga")
gs <- growthstandards::igb_value2centile(val = weight_kg, gagebrth = gestage,
                                         sex = "Male", var = "wtkg")
waldo::compare(gigs, gs / 100, x_arg = "gigs", y_arg = "growthstandards")
```

# INTERGROWTH-21<sup>st</sup> Postnatal Growth standards
The `r ig21st` Postnatal Growth standards are implemented in gigs for R and
Stata, and in the **growthstandards** package. Let's make a new dataset,
`ds_ig_png`, which we will use to benchmark these functions:
```{r ds_ig_png}
ac_ig_png <- "wfa"
ds_ig_png <- benchmark_dataset(n = 100000,
                               family = "ig_png",
                               acronym = ac_ig_png)
```


The first 10 rows of this dataset look like this:
```{r show_bench_dataset4}
ds_ig_png[1:10, ]
```

## Timing
### R
```{r bp_ig_png, echo = TRUE, eval = FALSE}
bp_ig_png_r <- bench::press(
  input_len = c(1, 1000, 10000, seq(25000, 100000, 25000)),
  {
    weight_kg <- ds_ig_png$y[1:input_len]
    pma_weeks <- ds_ig_png$x[1:input_len]
    pma_days <- (pma_weeks * 7)[1:input_len]
    acronym <- ds_ig_png$acronym[1:input_len]
    sex <- ds_ig_png$sex[1:input_len]
    sex_gs <- ifelse(sex == "M", "Male", "Female")
    bench::mark(
      check = FALSE, filter_gc = TRUE, time_unit = "ms", min_iterations = 50,
      gigs = gigs::value2zscore(weight_kg, pma_weeks, sex,
                                family = "ig_png", acronym = ac_ig_png),
      gs = growthstandards::igprepost_value2zscore(val = weight_kg,
                                                   pmagedays = pma_days,
                                                   sex = sex_gs, var = "wtkg")
    )
  }) |>
  dplyr::mutate(desc = attr(expression, which = "description")) |>
  dplyr::select(input_len, median, desc)
```

### Stata
```{r, eval = FALSE}
# Save .dta file equivalent of benchmarking table. This can be used to benchmark
# Stata packages.
haven::write_dta(
  data = ds_ig_png,
  path = file.path("exclude", "statabench", "bench_ds_ig_png.dta")
)
```

```{stata stata_bench_code_ig_png, eval = FALSE}
// This is Stata code
foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_ig_png.dta", clear
	qui drop if _n > `i'
	di "Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen double z_gigs = ig_png(y, "wfa", "v2z"), ///
			xvar(x) sex(sex) sexcode(m=M, f=F)
}
```

```{r bp_ig_png_stata, echo = FALSE, eval = FALSE}
bp_ig_png_stata <- read.csv("exclude/statabench/stata_bench.csv")
bp_ig_png_stata <- bp_ig_png_stata[bp_ig_png_stata$acronym == "ig_png", ]
bp_ig_png_stata <- bp_ig_png_stata[, -4]
```

### SAS
```{r sas_ds_ig_png, eval = FALSE}
# Save .txt file equivalent of benchmarking table. This can be used to benchmark
# SAS package.
write.table(ds_ig_png,
            file = file.path("exclude", "sasbench", "bench_ds_ig_png.txt"),
            sep = ",",
            row.names = FALSE,
            col.names = FALSE,
            quote = FALSE)
```

In SAS, the commands are run inside a script described at the [bottom of this
article](#sas-code). This code essentially does the same as `bench::press()`,
but for the SAS implementation of **gigs**.

```{r bp_ig_png_sas, echo = FALSE, eval = FALSE}
sas_ig_png <- read.csv("exclude/sasbench/sas_bench.csv")
sas_ig_png <- sas_ig_png[sas_ig_png$family == "ig_png", ]
bp_ig_png_sas <-  data.frame(input_len = sas_ig_png$k,
                             median = sas_ig_png$median,
                             desc = "gigs_sas")
rm(sas_ig_png)
```

## Package comparisons: timing
```{r make_bp_ig_png, eval = FALSE, echo = FALSE}
bp_ig_png <- dplyr::bind_rows(bp_ig_png_r, bp_ig_png_stata, bp_ig_png_sas)
```

```{r plot_timings_ig_png, echo = FALSE, fig.alt = "A line graph of median time taken against no. of inputs for the analysed software packages in the INTERGROWTH-21st Postnatal Growth standard for weight-for-age. The results can be read about below."}
plot_bp(bp_ig_png)
```

For the `r intergrowth21st` Postnatal Growth standards, the Stata implementation
for GIGS is the slowest at ~`r max_median(bp_ig_png, "gigs_stata")` ms. Next is
**gigs** for SAS, which takes around ~`r max_median(bp_ig_png, "gigs_sas")` ms.
The **gigs** and **growthstandards** packages are the fastest at
~`r max_median(bp_ig_png, "gs")` and ~`r max_median(bp_ig_png, "gigs")` ms,
respectively.

# INTERGROWTH-21<sup>st</sup> Fetal standards
The `r ig21st` Fetal standards are implemented in gigs for R and Stata, and in
the **growthstandards** and **intergrowth** packages (though more fully in
**intergrowth**  than in **growthstandards**, and both are missing some
standards which are included in **gigs**). Let's make a new dataset,
`ds_ig_fet`, which we will use to benchmark a conversion in a fetal growth
standard common to all three packages:

```{r ds_ig_fet}
ac_ig_fet <- "ofdfga"
ds_ig_fet <- benchmark_dataset(n = 100000,
                               family = "ig_fet",
                               acronym = ac_ig_fet)
```


The first 10 rows of this dataset look like this:
```{r show_bench_dataset_ig_fet, eval = FALSE}
ds_ig_fet[1:10, ]
```

## Timing
### R
```{r bp_ig_fet, echo = TRUE, eval = FALSE}
bp_ig_fet_r <- bench::press(
  input_len = c(1, 1000, 10000, seq(25000, 100000, 25000)),
  {
    gest_days <- ds_ig_fet$x[1:input_len]
    gest_wks <- gest_days / 7
    acronym <- ds_ig_fet$acronym[1:input_len]
    ofd_mm <- ds_ig_fet$y[1:input_len]
    ofd_cm <- ofd_mm / 10
    bench::mark(
      check = FALSE, filter_gc = TRUE, time_unit = "ms", min_iterations = 50,
      gigs = gigs::value2zscore(ofd_mm, gest_days,
                                family = "ig_fet", acronym = ac_ig_fet),
      gs = growthstandards::igfet_value2zscore(val = ofd_cm,
                                               gagedays = gest_days,
                                               var = "ofdcm"),
      intergrowth = intergrowth::calculate_ofd_gestage(ofd = ofd_mm,
                                                       gestage = gest_wks)[[1]],
    )
  }) |>
  dplyr::mutate(desc = attr(expression, which = "description")) |>
  dplyr::select(input_len, median, desc)
```

### Stata
```{r, eval = FALSE}
# Save .dta file equivalent of benchmarking table. This can be used to benchmark
# Stata packages.
haven::write_dta(
  data = ds_ig_fet,
  path = file.path("exclude", "statabench", "bench_ds_ig_fet.dta")
)
```

```{stata stata_bench_code_ig_fet, eval = FALSE}
// This is Stata code
foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_ig_fet.dta", clear
	qui drop if _n > `i'
	di "Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen double z_gigs = ig_fet(y, "ofdfga", "v2z"), xvar(x)
}
```

```{r bp_ig_fet_stata, echo = FALSE, eval = FALSE}
bp_ig_fet_stata <- read.csv("exclude/statabench/stata_bench.csv")
bp_ig_fet_stata <- bp_ig_fet_stata[bp_ig_fet_stata$acronym == "ig_fet", ]
bp_ig_fet_stata <- bp_ig_fet_stata[, -4]
```

### SAS
```{r sas_ds_ig_fet, eval = FALSE}
# Save .txt file equivalent of benchmarking table. This can be used to benchmark
# SAS package.
write.table(ds_ig_fet,
            file = file.path("exclude", "sasbench", "bench_ds_ig_fet.txt"),
            sep = ",",
            row.names = FALSE,
            col.names = FALSE,
            quote = FALSE)
```

In SAS, the commands are run inside a script described at the [bottom of this
article](#sas-code). This code essentially does the same as `bench::press()`,
but for the SAS implementation of **gigs**.

```{r bp_ig_fet_sas, echo = FALSE, eval = FALSE}
sas_ig_fet <- read.csv("exclude/sasbench/sas_bench.csv")
sas_ig_fet <- sas_ig_fet[sas_ig_fet$family == "ig_fet", ]
bp_ig_fet_sas <-  data.frame(input_len = sas_ig_fet$k,
                             median = sas_ig_fet$median,
                             desc = "gigs_sas")
rm(sas_ig_fet)
```

## Package comparisons: timing
```{r make_bp_ig_fet, eval = FALSE, echo = FALSE}
bp_ig_fet <- dplyr::bind_rows(bp_ig_fet_r, bp_ig_fet_stata, bp_ig_fet_sas)
```

```{r plot_timings_ig_fet, echo = FALSE, fig.alt = "A line graph of median time taken against no. of inputs for the analysed software packages in the INTERGROWTH-21st Fetal standard for occipito-frontal diameter-for-gestational age. The results can be read about below."}
plot_bp(bp_ig_fet)
```

For the `r intergrowth21st` Fetal standard for occipito-frontal diameter, the
GIGS implementation for SAS is the slowest to analyse 100,000 inputs at
~`r max_median(bp_ig_fet, "gigs_sas")` ms. Next is **gigs** for Stata, at
~`r max_median(bp_ig_fet, "gigs_stata")` ms. The R **gigs** package is the
fastest at ~`r max_median(bp_ig_fet, "gigs")` ms, followed by
**growthstandards** at ~`r max_median(bp_ig_fet, "gs")`ms, and then
**intergrowth** at ~`r max_median(bp_ig_fet, "intergrowth")`ms.

# Summary

## Timings summary (100,000 inputs)

```{r save_timings, echo = FALSE, eval = FALSE}
max_median_all <- function(bp) {
  vapply(X = unique(bp$desc),
         FUN = \(desc) max_median(bp, desc),
         FUN.VALUE = double(1L))
}

max_len_bench <- list(
  who_gs = max_median_all(bp_who_gs),
  ig_nbs = max_median_all(bp_ig_nbs),
  ig_png = max_median_all(bp_ig_png),
  ig_fet = max_median_all(bp_ig_fet)
)
```

| Software        | Platform | WHO (0-5 years) (ms)                      | `r ig21st` NBS (ms)                    | `r ig21st` PNG (ms)                    | `r ig21st` Fetal (ms)                   |
|-----------------|----------|-------------------------------------------|----------------------------------------|----------------------------------------|-----------------------------------------|
| `r gigs_r`      | R        | `r max_len_bench[[1]][["gigs"]]`          | `r max_len_bench[[2]][["gigs"]]`       | `r max_len_bench[[3]][["gigs"]]`       | `r max_len_bench[[4]][["gigs"]]`        |
| `r anthro`      | R        | `r max_len_bench[[1]][["anthro"]]`        | `r no`                                 | `r no`                                 | `r no`                                  |
| `r AGD`         | R        | `r max_len_bench[[1]][["AGD"]]`           | `r no`                                 | `r no`                                 | `r no`                                  |
| `r childsds`    | R        | `r max_len_bench[[1]][["childsds"]]`      | `r no`                                 | `r no`                                 | `r no`                                  |
| `r growthstans` | R        | `r max_len_bench[[1]][["gs"]]`            | `r  max_len_bench[[2]][["gs"]]`        | `r max_len_bench[[3]][["gs"]]`         | `r max_len_bench[[4]][["gs"]]`          |
| `r intergrowth` | R        | `r no`                                    | `r no`                                 | `r no`                                 | `r max_len_bench[[4]][["intergrowth"]]` |
| `r sitar`       | R        | `r max_len_bench[[1]][["sitar"]]`         | `r no`                                 | `r no`                                 | `r no`                                  |
| `r zscorer`     | R        | NA                                        | `r no`                                 | `r no`                                 | `r no`                                  |
| `r gigs_stata`  | Stata    | `r max_len_bench[[1]][["gigs_stata"]]`    | `r max_len_bench[[2]][["gigs_stata"]]` | `r max_len_bench[[3]][["gigs_stata"]]` | `r max_len_bench[[4]][["gigs_stata"]]`  |
| `r zanthro`     | Stata    | `r max_len_bench[[1]][["zanthro_stata"]]` | `r no`                                 | `r no`                                 | `r no`                                  |
| `r gigs_sas`    | SAS      | `r max_len_bench[[1]][["gigs_sas"]]`      | `r max_len_bench[[2]][["gigs_sas"]]`   | `r max_len_bench[[3]][["gigs_sas"]]`   | `r max_len_bench[[4]][["gigs_sas"]]`    |

Note: **zscorer** is NA because we couldn't time it for 100,000 inputs (it takes
too long).

## Why GIGS?
Overall, though the **gigs** package for R isn't always the fastest, it is only
some milliseconds off, and offers:

  * A full complement of international growth standards (i.e. no
    half-implemented sets of growth standards)
  * More accurate implementations in some cases
  * Growth categorisation functions

Some users may want to apply growth references in their work - that's fine, and
other R packages (e.g. **childsds** in R and **zanthro** in Stata) offer
reference charts which may be of use to end-users. However, for international
growth standards, we believe we offer the best combination of speed and range of
standards.

In R, **gigs** also offers input checking via its options, and will tell you if
you're providing non-workable data. We think this benefit outweighs some
milliseconds-worth of slowdown. In Stata, where **gigs** consistently runs
faster and offers more growth standards than **zanthro**, **gigs** is the
obvious choice.

# Session information
```{r session_info1, echo = TRUE, eval = FALSE}
sessionInfo()
```

```{r session_info2, echo = FALSE, eval = FALSE}
session_info <- sessionInfo()
```

```{r session_info3, echo = FALSE, eval = TRUE}
session_info
```



[//]: # (Code to save/load all timings tables in a separate .rda file)
```{r save_benchmarking_rda, eval = FALSE, echo = FALSE}
save(file = file.path("vignettes/articles/benchmarking.rda"),
     bp_who_gs, bp_ig_nbs, bp_ig_png, bp_ig_fet, max_len_bench, session_info)
```

# Non-R code

## Stata code

```{stata, eval = FALSE}
// Set path to directory with benchmarking datasets
local path = "D:\path\to\directory"
cd "`path'"

log using "`path'\statabench.log", replace text nomsg

// WHO Child Growth Standards
foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_who_gs.dta", clear
	qui drop if _n > `i'
	di "Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen double z_gigs = who_gs(y, "wfa", "v2z"), ///
			xvar(x) sex(sex) sexcode(m=M, f=F)
}

foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_who_gs.dta", clear
	qui drop if _n > `i'
	di "Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen z_anthro = zanthro(y, wa, WHO), xvar(x) gender(sex) ///
			gencode(male=M, female=F) ageunit(day)
}

// IG-21st Newborn Size Standards
foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_ig_nbs.dta", clear
	qui drop if _n > `i'
	di "Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen double z_gigs = ig_nbs(y, "wfga", "v2z"), ///
			gest_days(gest_days) sex(sex) sexcode(m=M, f=F)
}

// IG-21st Postnatal Growth Standards
foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_ig_png.dta", clear
	qui drop if _n > `i'
	di "Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen double z_gigs = ig_png(y, "wfa", "v2z"), ///
			xvar(x) sex(sex) sexcode(m=M, f=F)
}

// IG-21st Fetal Standards
foreach i in 1 10 100 500 1000 5000 10000 25000 50000 75000 100000 {
	use "bench_ds_ig_fet.dta", clear
	qui drop if _n > `i'
	di "Number of inputs: `i'"
	bench, reps(25) restore last: ///
		qui egen double z_gigs = ig_fet(y, "ofdfga", "v2z"), xvar(x)
}

log close
```

The resulting log file has our timings, albeit in a slightly annoying format.
This bit of R code converts that file into a CSV for easy reading into R.

```{r extract_stata_timings, eval = FALSE}
# logfile <- "../exclude/statabench/statabench.log"
logfile <- readr::read_lines("exclude/statabench/statabench.log")

logfile_to_df <- function(logfile, acronym) {
  pattern <- paste0("^For ", acronym, "|Average")
  log_subset <- logfile[grepl(x = logfile, pattern = pattern)]

  hits <- which(grepl(x = log_subset, pattern = paste0("^For ", acronym)))
  pasted <- paste(log_subset[hits], log_subset[hits + 1])

  n_inputs <- stringr::str_extract(pasted, pattern = "(?<=inputs\\: ).*(?= A)") |>
    as.integer()
  median <- stringr::str_extract(pasted, pattern = "(?<=runs\\: ).*(?= s)") |>
    as.double()
  desc_pattern <- paste0("(?<=", acronym, " ).*(?= -)")
  desc <- stringr::str_extract(pasted, pattern = desc_pattern)
  df <- data.frame(input_len = n_inputs,
                   median = median * 1000, # Convert secs to ms
                   desc = desc,
                   acronym = acronym)
}

stata_bench <- purrr::map_dfr(.x = c("who_gs", "ig_nbs", "ig_png", "ig_fet"),
                              .f = \(acronym) logfile_to_df(logfile, acronym))
write.csv(stata_bench, file = "exclude/statabench/stata_bench.csv",
          row.names = FALSE)

rm(logfile_to_df, logfile, stata_bench)
```

## SAS code

Unlike the Stata benchmarking code, the SAS code automatically outputs the
data to a CSV file.

```{sas, eval = FALSE}
/* SAS benchmarking code - Written by Bartosz Jablonski, Nov 2024 */
/*                                                                */
/* To run this script, you need to install the GIGS package for   */
/* SAS. This requires you to follow the installation instructions */
/* at  https://github.com/SASPAC/gigs/.                           */

filename packages "D:\Users\tadeo\Documents\SASPAC";
%include packages(SPFinit.sas);
%loadPackage(gigs)

/* path for files with data */
%let path=D:\Users\tadeo\Documents\gigs\exclude\sasbench;

data bench_ds_ig_fet;
infile "&path/bench_ds_ig_fet.txt" dlm=",";
input z x family :$20. acronym :$20. y; /* sex :$2.;*/
run;

%macro readFiles(file);
data &file.;
infile "&path/&file..txt" dlm=",";
input
z x sex :$2. family :$20. acronym :$20. y;
run;
%mend readFiles;

%readFiles(bench_ds_ig_nbs)
%readFiles(bench_ds_ig_png)
%readFiles(bench_ds_who_gs)


%macro loopBench(data,call,reps=25);
%array(i[11] (1 10 100 500 1000 5000 10000 25000 50000 75000 100000),macarray=Y) /**/
%put %do_over(i);

SASFILE &data. load;

%local j k l;
%do j=1 %to &iHBOUND.;
  %let k=%i(&j.);


  %do l=1 %to &reps.; /* read data set read the "number of repetitions" times */

  data loop_&data._&k._&l.(BUFSIZE=4k compress=no);
    t0=time();
    u=0;

    do until(_E_);
      set
          &data.(obs=&k.) /* select only k first observations */
      end=_E_;
      /*n+(round(z,0.000001)=round(&call.,0.000001));*/
      t=time();
      n=&call.; /* function call on a single observation */
      u+(time()-t);
    end;

    t=(time()-t0);
    k=&k.;
    l=&l.;
    output;
    stop;
  run;
  %end;
%end;

SASFILE &data. close;

%mend loopBench;


options nomprint nosymbolgen nomlogic nonotes;
%loopBench(bench_ds_ig_fet,gigs_ig_fet_value2zscore(y, x, acronym))
%loopBench(bench_ds_ig_nbs,gigs_ig_nbs_value2zscore(y, x, sex, acronym))
%loopBench(bench_ds_ig_png,gigs_ig_png_value2zscore(y, x, sex, acronym))
%loopBench(bench_ds_who_gs,gigs_who_gs_value2zscore(y, x, sex, acronym))
options notes;

data _all_;
  set loop_:;
run;

proc sort data=_all_ out=plot;
  by family k l ;
run;

proc sql;
create table plot as
select family, k, avg(t) label='time in seconds' as tt, avg(u) as uu
from _all_
group by family, k;
run;

proc print data=plot;

data sas_bench;
  set plot;
  median=tt*1000;
run;

proc export data=sas_bench
  file="&path\sas_bench.csv"
  dbms=csv replace;
run;
```
